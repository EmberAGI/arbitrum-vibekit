<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sign Agent Registration Transaction</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,
          sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }

      .container {
        background: white;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        padding: 40px;
        max-width: 600px;
        width: 100%;
      }

      h1 {
        color: #333;
        margin-bottom: 10px;
        font-size: 28px;
      }

      .subtitle {
        color: #666;
        margin-bottom: 30px;
        font-size: 14px;
      }

      .info-box {
        background: #f7f9fc;
        border-left: 4px solid #667eea;
        padding: 15px;
        margin-bottom: 25px;
        border-radius: 4px;
      }

      .info-box strong {
        color: #333;
        display: block;
        margin-bottom: 5px;
      }

      .info-box code {
        background: #e1e8ed;
        padding: 2px 6px;
        border-radius: 3px;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        word-break: break-all;
      }

      .status {
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 20px;
        display: none;
      }

      .status.info {
        background: #e3f2fd;
        color: #1976d2;
        border: 1px solid #90caf9;
      }

      .status.success {
        background: #e8f5e9;
        color: #388e3c;
        border: 1px solid #81c784;
      }

      .status.error {
        background: #ffebee;
        color: #c62828;
        border: 1px solid #ef5350;
      }

      button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 14px 32px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        width: 100%;
        transition:
          transform 0.2s,
          box-shadow 0.2s;
      }

      button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .tx-hash {
        margin-top: 20px;
        padding: 15px;
        background: #f7f9fc;
        border-radius: 8px;
        word-break: break-all;
      }

      .tx-hash a {
        color: #667eea;
        text-decoration: none;
        font-weight: 600;
      }

      .tx-hash a:hover {
        text-decoration: underline;
      }

      .loader {
        border: 3px solid #f3f3f3;
        border-top: 3px solid #667eea;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        animation: spin 1s linear infinite;
        display: inline-block;
        margin-right: 10px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ü§ñ Register Your Agent</h1>
      <p class="subtitle">Sign the registration transaction with your wallet</p>

      <div id="agentInfo" class="info-box">
        <strong>Agent Details:</strong>
        <div id="agentDetails">Loading...</div>
      </div>

      <div id="status" class="status"></div>

      <button id="connectButton" onclick="connectWallet()">
        Connect Wallet & Sign Transaction
      </button>

      <div id="txHashContainer" style="display: none" class="tx-hash">
        <strong>Transaction Hash:</strong><br />
        <a id="txHashLink" target="_blank"></a>
      </div>
    </div>
    <script type="module">
      import { createPublicClient, createWalletClient, custom, defineChain, parseEventLogs, parseAbiItem } from 'https://esm.sh/viem@2.38.5';

      let walletClient = null;
      let publicClient = null;
      let txData = null;
      let injectedProvider = null;
      const announcedProviders = [];

      window.addEventListener('eip6963:announceProvider', (event) => {
        const { provider, info } = event.detail;
        announcedProviders.push({ provider, info });
        if (!injectedProvider || info?.rdns === 'io.metamask') {
          injectedProvider = provider;
        }
      });

      window.dispatchEvent(new Event('eip6963:requestProvider'));

      function resolveInjectedProvider() {
        if (injectedProvider) {
          return injectedProvider;
        }
        if (announcedProviders.length > 0) {
          const metamask = announcedProviders.find(({ info }) => info?.rdns === 'io.metamask');
          if (metamask) {
            injectedProvider = metamask.provider;
            return injectedProvider;
          }
          injectedProvider = announcedProviders[0]?.provider ?? null;
          return injectedProvider;
        }

        if (window.ethereum?.providers && Array.isArray(window.ethereum.providers)) {
          const metamaskProvider = window.ethereum.providers.find(
            (provider) => provider && provider.isMetaMask,
          );
          if (metamaskProvider) {
            injectedProvider = metamaskProvider;
            return injectedProvider;
          }
          injectedProvider = window.ethereum.providers[0];
          return injectedProvider;
        }
        injectedProvider = window.ethereum ?? null;
        return injectedProvider;
      }

      function buildViemChain(chainId) {
        if (!defineChain) {
          return null;
        }
        const metadata = CHAIN_METADATA[chainId];
        if (!metadata) {
          return null;
        }
        const networkName = metadata.chainName.toLowerCase().replace(/\s+/g, '-');
        return defineChain({
          id: chainId,
          name: metadata.chainName,
          network: networkName,
          nativeCurrency: metadata.nativeCurrency,
          rpcUrls: {
            default: { http: metadata.rpcUrls },
            public: { http: metadata.rpcUrls },
          },
          blockExplorers:
            metadata.blockExplorerUrls.length > 0
              ? { default: { name: `${metadata.chainName} Explorer`, url: metadata.blockExplorerUrls[0] } }
              : undefined,
        });
      }

      function ensureWalletClient(chainId) {
        if (!custom) {
          return;
        }

        const provider = resolveInjectedProvider();
        if (!provider) {
          return;
        }

        const chainConfig = buildViemChain(chainId);

        if (!walletClient && createWalletClient) {
          walletClient = createWalletClient({
            chain: chainConfig ?? undefined,
            transport: custom(provider),
          });
        }

        if (!publicClient && createPublicClient) {
          publicClient = createPublicClient({
            chain: chainConfig ?? undefined,
            transport: custom(provider),
          });
        }
      }

      async function isWalletUnlocked() {
        const provider = resolveInjectedProvider();
        const metaMask = provider?._metamask;
        if (metaMask && typeof metaMask.isUnlocked === 'function') {
          try {
            return await metaMask.isUnlocked();
          } catch (error) {
            console.log('Could not determine MetaMask lock state:', error);
          }
        }
        return true;
      }

      function isUserRejected(error) {
        let current = error;
        while (current) {
          if (typeof current?.code === 'number' && current.code === 4001) {
            return true;
          }
          if (UserRejectedRequestError && current instanceof UserRejectedRequestError) {
            return true;
          }
          current = current?.cause;
        }
        return false;
      }

      function isRequestPending(error) {
        let current = error;
        while (current) {
          if (typeof current?.code === 'number' && current.code === -32002) {
            return true;
          }
          current = current?.cause;
        }
        return false;
      }

      function isChainNotConfigured(error) {
        let current = error;
        while (current) {
          if (typeof current?.code === 'number' && current.code === 4902) {
            return true;
          }
          if (ChainNotConfiguredError && current instanceof ChainNotConfiguredError) {
            return true;
          }
          current = current?.cause;
        }
        return false;
      }

      const CHAIN_METADATA = {
        1: {
          chainId: '0x1',
          chainName: 'Ethereum Mainnet',
          nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
          rpcUrls: ['https://rpc.ankr.com/eth'],
          blockExplorerUrls: ['https://etherscan.io'],
        },
        11155111: {
          chainId: '0xaa36a7',
          chainName: 'Sepolia Testnet',
          nativeCurrency: { name: 'Sepolia Ether', symbol: 'ETH', decimals: 18 },
          rpcUrls: ['https://rpc.sepolia.org'],
          blockExplorerUrls: ['https://sepolia.etherscan.io'],
        },
        42161: {
          chainId: '0xa4b1',
          chainName: 'Arbitrum One',
          nativeCurrency: { name: 'Arbitrum Ether', symbol: 'ETH', decimals: 18 },
          rpcUrls: ['https://arb1.arbitrum.io/rpc'],
          blockExplorerUrls: ['https://arbiscan.io'],
        },
        421614: {
          chainId: '0x66eee',
          chainName: 'Arbitrum Sepolia',
          nativeCurrency: { name: 'Arbitrum Sepolia Ether', symbol: 'ETH', decimals: 18 },
          rpcUrls: ['https://sepolia-rollup.arbitrum.io/rpc'],
          blockExplorerUrls: ['https://sepolia.arbiscan.io'],
        },
      };

      // Parse URL parameters
      function parseParams() {
        const params = new URLSearchParams(window.location.search);
        const to = params.get('to');
        const data = params.get('data');
        const chainId = params.get('chainId');
        const agentName = params.get('agentName');

        if (!to || !data || !chainId) {
          showStatus('Missing required parameters (to, data, chainId)', 'error');
          document.getElementById('connectButton').disabled = true;
          return null;
        }

        return { to, data, chainId: parseInt(chainId), agentName };
      }

      // Display agent information
      function displayAgentInfo(params) {
        const detailsDiv = document.getElementById('agentDetails');
        if (params.agentName) {
          detailsDiv.innerHTML = `
                    <p style="margin-bottom: 10px;"><strong>Name:</strong> ${params.agentName}</p>
                    <p style="margin-bottom: 10px;"><strong>Chain ID:</strong> ${params.chainId}</p>
                    <p style="margin-bottom: 10px;"><strong>Registry Contract:</strong><br><code>${params.to}</code></p>
                `;
        } else {
          detailsDiv.innerHTML = `
                    <p style="margin-bottom: 10px;"><strong>Chain ID:</strong> ${params.chainId}</p>
                    <p style="margin-bottom: 10px;"><strong>Contract:</strong><br><code>${params.to}</code></p>
                `;
        }
      }

      // Show status message
      function showStatus(message, type = 'info') {
        const statusDiv = document.getElementById('status');
        statusDiv.className = `status ${type}`;
        statusDiv.innerHTML = message;
        statusDiv.style.display = 'block';
      }

      // Get block explorer URL
      function getExplorerUrl(chainId, txHash) {
        const explorers = {
          1: 'https://etherscan.io',
          11155111: 'https://sepolia.etherscan.io',
          42161: 'https://arbiscan.io',
          421614: 'https://sepolia.arbiscan.io',
        };
        const baseUrl = explorers[chainId] || 'https://etherscan.io';
        return `${baseUrl}/tx/${txHash}`;
      }

      // Request access to wallet accounts, handling common provider edge cases
      async function requestWalletAccounts(button) {
        if (!walletClient) {
          ensureWalletClient(txData?.chainId ?? 1);
        }
        if (!walletClient) {
          showStatus('Wallet client is not available. Ensure MetaMask is installed and try again.', 'error');
          button.disabled = false;
          button.textContent = 'Try Again';
          return null;
        }

        const unlocked = await isWalletUnlocked();
        if (!unlocked) {
          showStatus(
            'MetaMask appears to be locked. You may see an unlock prompt shortly; if not, open the MetaMask extension and unlock it manually.',
            'info',
          );
        }

        let addresses = [];

        if (typeof walletClient.getAddresses === 'function') {
          try {
            addresses = await walletClient.getAddresses();
          } catch (error) {
            console.log('walletClient.getAddresses failed:', error);
          }
        }

        if (Array.isArray(addresses) && addresses.length > 0) {
          return addresses;
        }

        if (typeof walletClient.requestAddresses === 'function') {
          try {
            addresses = await walletClient.requestAddresses();
          } catch (error) {
            if (isRequestPending(error)) {
              showStatus(
                'A MetaMask request is already pending. Open MetaMask and finish the request, then click Try Again.',
                'error',
              );
              button.disabled = false;
              button.textContent = 'Try Again';
              return null;
            }
            if (isUserRejected(error)) {
              showStatus(
                'MetaMask blocked the connection. Open the extension, select an account, approve the request, then click Try Again.',
                'error',
              );
            } else if (error instanceof Error && error.message) {
              showStatus(`Failed to connect to wallet: ${error.message}`, 'error');
            } else {
              showStatus('Failed to connect to wallet.', 'error');
            }
            button.disabled = false;
            button.textContent = 'Try Again';
            return null;
          }
        }

        if (Array.isArray(addresses) && addresses.length > 0) {
          return addresses;
        }

        showStatus(
          'MetaMask did not expose any accounts yet. Open the MetaMask extension, unlock/select an account, approve the connection, then click Try Again.',
          'error',
        );
        button.disabled = false;
        button.textContent = 'Try Again';
        return null;
      }

      async function ensureCorrectChain(button, chainId) {
        if (!walletClient) {
          showStatus('Wallet client is not available. Refresh and try again.', 'error');
          button.disabled = false;
          button.textContent = 'Try Again';
          return false;
        }

        try {
          const currentChainId = await walletClient.getChainId();
          if (typeof currentChainId === 'number' && currentChainId === chainId) {
            return true;
          }
        } catch (error) {
          console.log('Could not determine current chain ID:', error);
        }

        try {
          await walletClient.switchChain({ id: chainId });
          return true;
        } catch (error) {
          if (isChainNotConfigured(error)) {
            return await addChainWithMetadata(button, chainId);
          }
          if (isUserRejected(error)) {
            showStatus(
              'Network switch was rejected. Approve the network prompt in MetaMask, then click Try Again.',
              'error',
            );
          } else if (isRequestPending(error)) {
            showStatus(
              'A network switch request is already pending. Open MetaMask and finish it, then click Try Again.',
              'error',
            );
          } else if (error instanceof Error && error.message) {
            showStatus(`Unable to switch networks automatically: ${error.message}`, 'error');
          } else {
            showStatus(
              `Unable to switch networks automatically. Switch to chain ID ${chainId} in your wallet, then try again.`,
              'error',
            );
          }
          button.disabled = false;
          button.textContent = 'Try Again';
          return false;
        }
      }

      async function addChainWithMetadata(button, chainId) {
        if (!walletClient || typeof walletClient.addChain !== 'function') {
          showStatus(
            `This network (chain ID ${chainId}) is not configured in MetaMask. Add it manually, then try again.`,
            'error',
          );
          button.disabled = false;
          button.textContent = 'Try Again';
          return false;
        }

        const chainConfig = buildViemChain(chainId);
        if (!chainConfig) {
          showStatus(
            `Chain metadata for ${chainId} is unavailable. Add it to your wallet manually, then try again.`,
            'error',
          );
          button.disabled = false;
          button.textContent = 'Try Again';
          return false;
        }

        try {
          await walletClient.addChain({ chain: chainConfig });
          await walletClient.switchChain({ id: chainId });
          return true;
        } catch (error) {
          if (isUserRejected(error)) {
            showStatus(
              'Network addition was rejected. Approve the prompt in MetaMask, then click Try Again.',
              'error',
            );
          } else if (isRequestPending(error)) {
            showStatus(
              'A MetaMask request is already pending. Open MetaMask and finish it, then click Try Again.',
              'error',
            );
          } else if (error instanceof Error && error.message) {
            showStatus(`Could not add the network automatically: ${error.message}`, 'error');
          } else {
            showStatus('Could not add the network automatically.', 'error');
          }
          button.disabled = false;
          button.textContent = 'Try Again';
          return false;
        }
      }

      // Connect wallet and sign transaction
      async function connectWallet() {
        const button = document.getElementById('connectButton');
        button.disabled = true;

        try {
          ensureWalletClient(txData?.chainId ?? 1);

          if (!walletClient) {
            showStatus('Could not initialise wallet client. Refresh and try again.', 'error');
            button.disabled = false;
            button.textContent = 'Try Again';
            return;
          }

          showStatus('<span class="loader"></span> Connecting to wallet...', 'info');

          const accounts = await requestWalletAccounts(button);
          if (!accounts || accounts.length === 0) {
            return;
          }

          const account = String(accounts[0]);
          showStatus(`Connected: ${account.slice(0, 6)}...${account.slice(-4)}`, 'success');

          showStatus('<span class="loader"></span> Switching to correct network...', 'info');
          const chainReady = await ensureCorrectChain(button, txData.chainId);
          if (!chainReady) {
            return;
          }

          showStatus(
            '<span class="loader"></span> Please confirm the transaction in your wallet...',
            'info',
          );

          const txHash = await walletClient.sendTransaction({
            account: accounts[0],
            to: txData.to,
            data: txData.data,
          });

          showStatus(
            `<span class="loader"></span> Transaction submitted! Waiting for confirmation...`,
            'info',
          );

          const txHashContainer = document.getElementById('txHashContainer');
          const txHashLink = document.getElementById('txHashLink');
          txHashLink.href = getExplorerUrl(txData.chainId, txHash);
          txHashLink.textContent = txHash;
          txHashContainer.style.display = 'block';

          let receipt;
          if (publicClient && typeof publicClient.waitForTransactionReceipt === 'function') {
            receipt = await publicClient.waitForTransactionReceipt({ hash: txHash });
          } else if (walletClient && typeof walletClient.waitForTransactionReceipt === 'function') {
            receipt = await walletClient.waitForTransactionReceipt({ hash: txHash });
          } else {
            throw new Error('Unable to wait for transaction receipt with the current viem client.');
          }

          const agentIdInfo = await decodeAgentId(receipt, accounts[0], txData.to);
          if (agentIdInfo !== null) {
            const agentIdDisplay = agentIdInfo.decimal;
            const agentIdHex = agentIdInfo.hex;
            const source = agentIdInfo.source === 'historical' ? ' (retrieved from historical logs)' : '';
            const statusMessage =
              agentIdInfo.isSafeInteger
                ? `‚úÖ Transaction confirmed! Your agent has been registered.<br><strong>Agent ID: ${agentIdDisplay}</strong>${source}<br><br>‚úÖ Registration complete. You can now close this page.`
                : `‚úÖ Transaction confirmed! Your agent has been registered.<br><strong>Agent ID: ${agentIdDisplay}</strong><br><small>Hex: ${agentIdHex}</small>${source}<br><br>‚úÖ Registration complete. You can now close this page.`;
            showStatus(statusMessage, 'success');

            // Log transaction details for debugging
            console.log('Transaction hash:', txHash);
            console.log('Agent ID:', agentIdDisplay);
            console.log('Source:', agentIdInfo.source);

            try {
              await fetch('/callback', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  agentId: agentIdInfo.isSafeInteger ? agentIdInfo.toNumber() : agentIdDisplay,
                  agentIdHex,
                  agentIdDecimal: agentIdDisplay,
                  txHash,
                }),
              });
            } catch (error) {
              console.log('Could not send agent ID to server:', error);
            }
          } else {
            // No agent ID found - show warning instead of silent success
            const explorerUrl = getExplorerUrl(txData.chainId, txHash);
            showStatus(
              `‚ö†Ô∏è Transaction confirmed but agent ID not found.<br>
              Transaction hash: <a href="${explorerUrl}" target="_blank">${txHash.slice(0, 10)}...</a><br>
              <button onclick="window.location.reload()">Search Again</button><br><br>
              Registration complete. You can close this page. Check your terminal for recovery instructions.`,
              'error'
            );

            // Log full receipt for debugging
            console.error('Failed to retrieve agent ID. Transaction receipt:', receipt);
            console.log('Transaction hash:', txHash);

            // Still send callback with pending flag
            try {
              await fetch('/callback', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  pendingAgentId: true,
                  txHash,
                }),
              });
            } catch (error) {
              console.log('Could not send pending status to server:', error);
            }
          }

          button.textContent = 'Close';
          button.onclick = () => window.close();
        } catch (error) {
          console.error('Error:', error);
          let errorMessage = 'Transaction failed';

          if (isUserRejected(error)) {
            errorMessage =
              'Wallet request was rejected. Please approve the prompts in your wallet and try again.';
          } else if (isRequestPending(error)) {
            errorMessage =
              'A wallet request is already pending. Open your wallet extension and finish that request, then try again.';
          } else if (error?.code === 4100) {
            errorMessage = 'Your wallet is locked. Unlock it, then click Try Again.';
          } else if (
            typeof error?.message === 'string' &&
            error.message.toLowerCase().includes('wallet must has at least one account')
          ) {
            errorMessage =
              'No wallet account available. Unlock your wallet or create an account, then try again.';
          } else if (error instanceof Error && error.message) {
            errorMessage = error.message;
          }

          showStatus(`‚ùå ${errorMessage}`, 'error');
          button.disabled = false;
          button.textContent = 'Try Again';
        }
      }

      window.connectWallet = connectWallet;

      // Decode agent ID from transaction receipt with fallback to historical logs
      async function decodeAgentId(receipt, account, contractAddress) {
        try {
          // Define the Registered event ABI
          const registeredEventAbi = {
            anonymous: false,
            inputs: [
              {
                indexed: true,
                internalType: 'uint256',
                name: 'agentId',
                type: 'uint256',
              },
              {
                indexed: false,
                internalType: 'string',
                name: 'tokenURI',
                type: 'string',
              },
              {
                indexed: true,
                internalType: 'address',
                name: 'owner',
                type: 'address',
              },
            ],
            name: 'Registered',
            type: 'event',
          };

          // First, try to parse the logs from the receipt
          const parsedLogs = parseEventLogs({
            abi: [registeredEventAbi],
            logs: receipt.logs,
          });

          // Find the Registered event in the parsed logs
          const registeredEvent = parsedLogs.find((log) => log.eventName === 'Registered');

          if (registeredEvent && registeredEvent.args.agentId !== undefined) {
            console.log('Found agent ID in transaction receipt');
            const agentIdBigInt = BigInt(registeredEvent.args.agentId);
            const isSafeInteger = agentIdBigInt <= BigInt(Number.MAX_SAFE_INTEGER);
            return {
              hex: `0x${agentIdBigInt.toString(16)}`,
              decimal: agentIdBigInt.toString(10),
              isSafeInteger,
              toNumber: () => Number(agentIdBigInt),
              source: 'receipt',
            };
          }

          // Fallback: Query historical logs if not found in receipt
          console.log('Agent ID not found in receipt, querying historical logs...');
          showStatus('<span class="loader"></span> Searching for agent ID in historical logs...', 'info');

          if (!publicClient) {
            console.error('Public client not available for historical query');
            return null;
          }

          // Parse the event signature for getLogs
          const registeredEventSignature = parseAbiItem(
            'event Registered(uint256 indexed agentId, string tokenURI, address indexed owner)'
          );

          // Query historical logs for this owner
          const logs = await publicClient.getLogs({
            address: contractAddress,
            event: registeredEventSignature,
            args: {
              owner: account,
            },
            fromBlock: BigInt(0), // Could optimize with deployment block
            toBlock: 'latest',
          });

          if (logs && logs.length > 0) {
            // Use the most recent registration (last in array)
            const mostRecentLog = logs[logs.length - 1];
            const agentIdBigInt = BigInt(mostRecentLog.args.agentId);
            const isSafeInteger = agentIdBigInt <= BigInt(Number.MAX_SAFE_INTEGER);

            console.log(`Found ${logs.length} agent(s) for this owner, using most recent: ${agentIdBigInt.toString()}`);

            return {
              hex: `0x${agentIdBigInt.toString(16)}`,
              decimal: agentIdBigInt.toString(10),
              isSafeInteger,
              toNumber: () => Number(agentIdBigInt),
              source: 'historical',
            };
          }

          console.log('No agents found for this owner in historical logs');
        } catch (error) {
          console.error('Error decoding agent ID:', error);
        }
        return null;
      }

      // Initialize on page load
      window.addEventListener('DOMContentLoaded', () => {
        txData = parseParams();
        if (txData) {
          displayAgentInfo(txData);
        }
      });
    </script>
  </body>
</html>

# Troubleshooting: USDai Strategy Workflow Integration Test

Branch: test/workflow-lifecycle | Updated: 2025-10-18T12:00:00Z

## Current Focus

Implementing comprehensive integration test for `usdai-strategy.ts` workflow per PRD.
Currently: Setting up test structure and planning implementation.

## Evidence Collected

### PRD Key Requirements
- **Hybrid approach**: Wallet upgrade is REAL blockchain transaction, workflow operations are MOCKED
- **Test file**: `tests/integration/usdai-strategy-workflow.int.test.ts`
- **Pattern foundation**: Use `a2a-client-protocol.int.test.ts` and `workflow-lifecycle.e2e.test.ts` as references
- **Two pause cycles**:
  1. Wallet address + amount input
  2. Signed delegations submission
- **Artifacts to validate**:
  - `delegations-to-sign` with approve + supply delegations
  - `transaction-executed` for approve (if needed)
  - `transaction-executed` for supply
- **Status transitions**: working → input-required → working → input-required → working → completed

### Environment Variables Required
- `A2A_TEST_7702_PRIVATE_KEY` - User test wallet (needs ~0.01 ETH for upgrade gas)
- `A2A_TEST_AGENT_NODE_PRIVATE_KEY` - Agent wallet
- `A2A_TEST_CHAIN_ID=42161` - Arbitrum One
- RPC URLs for real wallet upgrade transaction

### Reference Files
- `/Users/tomdaniel/Desktop/arbitrum-vibekit/typescript/lib/agent-node/tests/integration/a2a-client-protocol.int.test.ts` - Workflow dispatch, subscription, pause/resume patterns
- `/Users/tomdaniel/Desktop/arbitrum-vibekit/typescript/lib/agent-node/tests/e2e/workflow-lifecycle.e2e.test.ts` - Delegation signing patterns
- `/Users/tomdaniel/Desktop/arbitrum-vibekit/typescript/lib/agent-node/tests/utils/lifecycle-test-helpers.ts` - Test utilities
- `/Users/tomdaniel/Desktop/arbitrum-vibekit/typescript/lib/agent-node/tests/fixtures/workflows/usdai-strategy.ts` - Workflow being tested

## Assumptions

1. Test wallet is already funded with sufficient ETH for upgrade (if needed)
2. MMDT SDK is already installed and compatible
3. MSW handlers will need to mock: eth_call, eth_sendUserOperation, eth_getUserOperationReceipt, pm_sponsorUserOperation
4. Wallet upgrade will be checked first, only executed if needed
5. Existing test helpers can handle delegation signing

## Implementation Plan

### Step 1: Test File Structure
Create `tests/integration/usdai-strategy-workflow.int.test.ts` with:
- Import all required dependencies (A2AClient, WorkflowRuntime, MMDT SDK, viem, test helpers)
- Set 60s timeout for test
- Define test constants (USDAI_TOKEN, PENDLE_SWAP, TEST_AMOUNT)

### Step 2: Test Setup (beforeEach)
1. Initialize WorkflowRuntime
2. Register usdai-strategy workflow from fixtures
3. Create test A2A server with workflow runtime
4. Initialize A2AClient from agent card
5. Load test account from `A2A_TEST_7702_PRIVATE_KEY`
6. Initialize MMDT SDK clients (real Arbitrum RPC)
7. Check wallet upgrade status via eth_getCode
8. Conditionally execute wallet upgrade transaction (REAL)
9. Wait for confirmation before proceeding

### Step 3: Test Execution Flow
1. **Dispatch workflow** via sendMessageStream()
2. Extract workflow task ID from referenceTaskIds
3. **Subscribe** via resubscribeTask()
4. **First pause**: Detect input-required, resume with wallet + amount
5. **Collect delegations artifact**: Extract from stream
6. **Sign delegations**: Use MMDT SDK + test account
7. **Second pause**: Detect input-required, resume with signed delegations
8. **Validate artifacts**: transaction-executed artifacts
9. **Validate completion**: Final status = completed
10. Validate all status transitions

### Step 4: MSW Handlers
Create handlers for workflow operations (NOT wallet upgrade):
- Token allowance checks (eth_call)
- Token balance checks (eth_call)
- User operation submission (eth_sendUserOperation)
- User operation receipt (eth_getUserOperationReceipt)
- Paymaster sponsorship (pm_sponsorUserOperation)

### Step 5: Assertions
- Workflow completes without timeout
- All expected artifacts received
- Status transitions match expected sequence
- Delegations have correct structure
- Signed delegations are valid

## Attempts Log

[2025-10-18T12:00:00Z] Starting implementation - reading PRD and planning approach
[2025-10-18T12:05:00Z] Created test file structure, fixed workflow environment variables
[2025-10-18T12:10:00Z] Installed @metamask/delegation-toolkit and permissionless packages
[2025-10-18T12:12:00Z] Fixed import path for test-server-with-stubs
[2025-10-18T12:13:00Z] Running first test attempt...
[2025-10-18T12:15:00Z] Discovered MSW blocking wallet upgrade RPC calls
[2025-10-18T12:20:00Z] Created utility script to upgrade wallet (scripts/upgrade-test-wallet.ts)
[2025-10-18T12:22:00Z] Ran upgrade script successfully - wallet upgraded to 0x1A71cf8876A3A40FBF4CaEd21E06a620C83Bf095
[2025-10-18T12:23:00Z] Updated test to assume wallet is pre-upgraded, removed upgrade logic from beforeEach
[2025-10-18T12:25:00Z] Fixed client initialization - must use A2AClient.fromCardUrl(), not destructure from server
[2025-10-18T12:26:00Z] Fixed message format - must include messageId, contextId, role in message object
[2025-10-18T12:30:00Z] Updated MSW mocks (workflow-dispatch.json and streaming-workflow-dispatch.json) to dispatch usdai_points_trading_strateg
[2025-10-18T12:35:00Z] Test now successfully dispatches workflow! Times out at 30s waiting for workflow operations
[2025-10-18T12:36:00Z] Next step: Need MSW mocks for RPC calls (eth_call for token balance/allowance, eth_sendUserOperation, etc.)
[2025-10-19T01:15:00Z] Attempt 4: Created MSW handlers and mock data
[2025-10-19T01:15:30Z] Created onchain-actions handler for `https://api.emberai.xyz` REST API
[2025-10-19T01:16:00Z] Created viem RPC mock files: eth_call, pimlico_getUserOperationGasPrice, eth_sendUserOperation, eth_getUserOperationReceipt
[2025-10-19T01:16:30Z] Test now receives "task" event but hangs after that - workflow not progressing
[2025-10-19T01:17:00Z] **INCORRECT HYPOTHESIS**: Initially thought workflow hangs at `toMetaMaskSmartAccount()` call
[2025-10-19T01:17:30Z] Added console.log debugging to workflow to trace execution
[2025-10-19T01:26:30Z] **ACTUAL ROOT CAUSE IDENTIFIED**: Workflow executes successfully but status events don't reach client!
[2025-10-19T01:26:45Z] Evidence:
  - Workflow logs show: execute() called → initial status yielded → agent wallet created → pause reached
  - Test logs show: Only receives "task" event, no "status-update" events
  - Workflow is yielding states correctly, but they're not being emitted as SSE events to client stream
[2025-10-19T01:27:00Z] **This is a workflow runtime event streaming issue, NOT a workflow execution or mocking issue**
[2025-10-19T01:27:15Z] The workflow is paused waiting for input, but test never receives the `input-required` status update
[2025-10-19T01:44:30Z] Attempt 5: Added `getTask` backfill prior to `resubscribeTask` and auto-resume first pause when initial state is input-required → stream still only emits initial `task` event; no status or artifact updates delivered; workflow remains blocked awaiting client input
[2025-10-19T01:56:00Z] Attempt 6: Updated test to consume `artifact-update` (SDK event shape) instead of `artifact` → no change; stream still only shows `task`
[2025-10-19T01:59:00Z] Attempt 7: Instrumented SDK server `tasks/resubscribe` to log events; confirmed it iterates and yields `status-update` for the child task while client side only receives the initial `task` → server is emitting; issue likely in client-side stream consumption or JSON-RPC/SSE framing
[2025-10-19T02:06:30Z] Attempt 8: Verified ExecutionEventQueue semantics (stops on `message` or final). Audited WorkflowHandler: no `message` events during active workflow; only `status-update` and `artifact-update` are published to child bus until completion. Also validated gating: child `task` persisted before status/artifacts are flushed
[2025-10-19T03:05:00Z] Attempt 9: Resume troubleshooting with plan to capture raw SSE; first reproduce failure by rerunning pause-only HTTP integration test with DEBUG logs enabled
[2025-10-19T03:07:00Z] Attempt 9 Result: Test still fails (timeout waiting for status updates); server logs confirm workflow pause/status events emitted, client still only logs initial `task`
[2025-10-19T03:12:00Z] Attempt 10: Build standalone debug harness to call `/a2a` `message/stream` via fetch and dump raw SSE frames to confirm whether `status-update` with `referenceTaskIds` appears on the wire
[2025-10-19T03:15:00Z] Attempt 10 Result: Harness shows SSE includes `status-update` with `referenceTaskIds` before final completion; confirms server emits expected event and framing is correct → client consumption bug isolated
[2025-10-19T03:20:00Z] Attempt 11: Hypothesis—DefaultRequestHandler.resubscribe only yields future events, so stored pause status never replays. Plan: wrap request handler to replay persisted status/artifact snapshots after initial task emission.
[2025-10-19T03:25:00Z] Attempt 11 Result: Implemented ReplayingRequestHandler and wired into server/test harness; pause-only test still timing out. Need to verify replay executes (instrument wrapper) and confirm resubscribe stream contents.
[2025-10-19T03:35:00Z] Attempt 12: SSE debug script confirms `resubscribe` stream replays `input-required` status, but stream remains open (no resume sent) leading to BodyTimeoutError; script blocks because workflow stays paused.
[2025-10-19T03:38:00Z] Finding: A2A client resume helper uses blocking `message/send`, which waits for workflow completion while paused → deadlock. Next step: resend resume with `configuration.blocking = false` before rerunning tests.
[2025-10-19T03:40:00Z] Decision: Removed custom ReplayingRequestHandler wrapper; reverting to stock A2A SDK behavior to keep investigation focused on underlying stream gap.

## Next Actions

- Compare end-to-end with working stub in `workflow-child-stream.int.test.ts`: ensure identical ordering (create bus → start persistence → publish task → then status/artifacts) in WorkflowHandler
- Inspect A2AExpressApp JSON-RPC SSE packaging to ensure each yielded event from `resubscribe()` is wrapped as `{ jsonrpc, id, result }` (no shape drift)
- Probe client `_parseA2ASseStream` by capturing raw SSE payload for `tasks/resubscribe` with `fetch` in an isolated repro to confirm multiple events arrive on the wire
- If needed, add a minimal stub-executor route to the app to validate client `resubscribeTask()` end-to-end independent of WorkflowRuntime

---

# Hand‑Off: HTTP SSE Streaming Gap After Workflow Dispatch

Updated: 2025-10-19T02:36Z

## TL;DR

- Server publishes and persists child workflow events (status-update/artifact-update) correctly
- A2A SDK `resubscribe()` iterates those events server-side
- Client (A2AClient) streams only the initial `task` event for USDai and fails to surface later status updates
- Deterministic pause-only flow confirms the same: server emits the parent reference status, but the parent stream consumer in tests never receives it

## What’s Verified Working

1) WorkflowRuntime → WorkflowHandler → EventBus → ResultManager → resubscribe() (no HTTP)
- Test: `typescript/lib/agent-node/tests/integration/workflow-handler-resubscribe.int.test.ts`
- Registers a pause-only plugin, dispatches via WorkflowHandler, uses DefaultRequestHandler.resubscribe(), resumes, and observes status updates until completion
- PASS: status-update events stream reliably

2) Server publishes correct parent reference event during AI dispatch
- Logs in pause-only HTTP test show:
  - "Dispatching workflow from stream"
  - "Started persistence loop for child task"
  - "Emitting workflow reference" with childTaskId
  - "Publishing completed status-update"
- This proves parent bus is publishing the referenceTaskIds status-update

## What’s Broken / Unknown

- USDai integration: `tests/integration/usdai-strategy-workflow.int.test.ts`
  - LLM dispatch succeeds (child workflow created, runs to pause)
  - Client sees only the initial `task` event on `resubscribeTask()`; no status-update/artifact-update make it to the client
  - Server logs show WorkflowHandler emits pause status and artifacts; ResultManager persists them

- Pause-only HTTP SSE test: `tests/integration/pause-only-workflow-http.int.test.ts`
  - Deterministic AI stub streams a single tool-call → StreamProcessor dispatches workflow → server logs show parent referenceTaskIds status
  - Parent stream collector fails to observe that status event; childTaskId remains undefined
  - Test times out waiting for childTaskId

## Repro Commands

- Direct handler (passing):
  - `cd typescript/lib/agent-node`
  - `DEBUG_TESTS=1 pnpm test:int tests/integration/workflow-handler-resubscribe.int.test.ts`

- USDai failing path:
  - `cd typescript/lib/agent-node`
  - `DEBUG_TESTS=1 pnpm test:int tests/integration/usdai-strategy-workflow.int.test.ts`

- Pause-only HTTP SSE (deterministic AI stub; currently failing to surface referenceTaskIds):
  - `cd typescript/lib/agent-node`
  - `DEBUG_TESTS=1 pnpm test:int tests/integration/pause-only-workflow-http.int.test.ts`

## Evidence (selected)

- Server side (pause-only HTTP test):
  - StreamProcessor: "Dispatching workflow from stream { name: 'dispatch_workflow_pause_only' }"
  - WorkflowHandler: "Started persistence loop for child task"
  - StreamProcessor: "Emitting workflow reference { parentTaskId: ..., childTaskId: ... }"
  - StreamProcessor: "Publishing completed status-update"

- Client side (same test):
  - Parent stream collector never logs a status-update with `referenceTaskIds`
  - Child task id remains undefined; test times out

- USDai test:
  - Workflow logs: execute() called → initial status yielded → agent wallet created → pause reached
  - Server handler logs: pause events and artifacts persisted
  - Client resubscribe stream: only a `task` event observed

## Hypotheses

1) A2AClient SSE consumption timing/race
- Parent stream may end too quickly after server writes the final message, causing the client iterator to not deliver intermediate status events if they arrive very close to stream end

2) JSON-RPC/SSE framing mismatch
- Potentially missing/wrong `id` on some streamed responses from server causes the client’s `_parseA2ASseStream` to ignore frames

3) Ordering of server writes
- The parent reference status and final completed status are emitted back-to-back; if the SSE connection flush/close behavior on the server side ends the stream too eagerly, the client may miss the earlier frame

4) Test collection pattern
- The for-await loop that reads the parent stream could be cancelled/ending at the wrong time; consider reading a few `.next()` steps synchronously before an await to avoid coalescing

## High-Confidence Next Steps

1) Capture raw SSE for parent stream (message/stream)
- In a new test (or augment pause-only HTTP test):
  - Use `fetch` POST to `/a2a` with JSON-RPC `{ method: 'message/stream', ... }`
  - Read `response.body` with a basic SSE parser (split on blank lines, parse `data:` lines)
  - Assert that the status-update with `referenceTaskIds` appears before the final completed status
  - If present on the wire, the bug is in A2AClient parsing/consumption logic

2) Add extra drain window before finishing server stream
- In SDK server (DefaultRequestHandler): after publishing completed status, ensure a short delay (a few ticks) before the loop ends to give the client time to flush/read the preceding event

3) Instrument A2AClient `_parseA2ASseStream`
- Log each parsed JSON-RPC frame’s `id` and `result.kind` (we already added minimal logging locally) and ensure that all frames match the original request id

4) Adjust test parent stream consumption
- Instead of a long-lived for-await collector, pull a few `.next()` iterations immediately and log the results, then fall back to a collector promise

## Acceptance Criteria for Closure

- Pause-only HTTP SSE test passes: `referenceTaskIds` is observed by client; resubscribeTask() yields status updates including `input-required` and `completed`
- USDai test passes: client resubscribeTask() surfaces status updates (at minimum `input-required`), artifacts appear (`delegations-to-sign`), and test completes

## Key Code Pointers

- Parent streaming and workflow dispatch:
  - StreamProcessor: `src/a2a/handlers/streaming/StreamProcessor.ts`
  - Tool event handling: `src/a2a/handlers/streaming/StreamEventHandler.ts`

- Workflow streaming to child bus:
  - WorkflowHandler: `src/a2a/handlers/workflowHandler.ts` (persistence loop, gating, event publishing)

- Client SSE:
  - A2AClient: `node_modules/@a2a-js/sdk/dist/client/index.cjs` (`sendMessageStream`, `_parseA2ASseStream`)

## Contact / Context

- Branch: `test/workflow-lifecycle`
- Env: `typescript/lib/agent-node/.env.test` (LOG_LEVEL=debug already set)
- Deterministic AI stub in `pause-only-workflow-http.int.test.ts` to avoid MSW variability

[2025-10-19T01:59:30Z] Attempt 6: Instrumented server `tasks/resubscribe` handler — confirmed it yields `status-update` events for child task while client stream still logs only the initial `task`; artifact updates appear to be published on runtime side but never surface in SSE consumer

## Discovered Patterns

### From a2a-client-protocol.int.test.ts
- Async event collection with promises
- Race condition handling with getTask() backfill
- Stream timeout management (5000ms)
- Proper cleanup in afterEach

### From workflow-lifecycle.e2e.test.ts
- Delegation signing using account.signTypedData()
- Artifact validation with schemas
- Multi-pause handling pattern

### From usdai-strategy.ts
- Agent wallet creation with MMDT SDK
- Two delegations: approveUsdai, supplyPendle
- Delegation redemption via DelegationManager

## Blockers/Questions

1. ~~**MSW handler specifics**: Need to determine exact RPC call patterns for approve/supply operations~~ **RESOLVED**: MSW handlers are intercepting wallet upgrade calls - need to allow passthrough
2. ~~**Wallet upgrade check**: How to reliably check if wallet is already upgraded (eth_getCode pattern?)~~ **RESOLVED**: eth_getCode is being intercepted by MSW
3. ~~**CRITICAL**: PRD requires wallet upgrade to be REAL blockchain transaction, but MSW is intercepting ALL RPC calls~~ **RESOLVED**: Created utility script to upgrade wallet before tests
4. ~~**Solution needed**: Either disable MSW handlers for Arbitrum RPC during setup, or configure bypass for wallet upgrade calls~~ **RESOLVED**: Wallet is now pre-upgraded via script

## Resolution

### Wallet Upgrade Strategy

Created a utility script `scripts/upgrade-test-wallet.ts` that:
- Performs one-time REAL blockchain transaction to upgrade wallet
- Uses `A2A_TEST_7702_PRIVATE_KEY` from `.env.test`
- Upgrades wallet to MMDT smart account on Arbitrum One
- Script command: `pnpm test:upgrade-wallet`

Test now assumes wallet is pre-upgraded:
- Removed wallet upgrade logic from `beforeEach`
- Test focuses purely on workflow lifecycle
- Smart account address: `0x1A71cf8876A3A40FBF4CaEd21E06a620C83Bf095`
- This approach aligns with PRD statement that "subsequent runs are fast as wallet upgrade persists"
